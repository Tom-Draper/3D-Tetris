<html>
  <head>
    <title>3D TetrisL</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script src="three.js"></script>
    <script>
      var scene, camera, radius;
      var blocks = [];
      var cubeLen = 1;
      var end = -1;
      var gameWidth = 10;
      var gameHeight = 16;
      var mouseDown = false;
      var startMouseX, startMouseY, mouseX, mouseY;
      startMouseX = mouseX = startMouseY = mouseY = 0;
      var startTheta, theta, startPhi, phi;
      startTheta = theta = 180;
      startPhi = phi = 74;
      var radius;

      
      init();
      animate();

      // Listen for keyboard events, to react to them.
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("mousemove", handleMouseMove);
      document.body.addEventListener(
        "mousedown",
        function(event) {
          event.preventDefault();
          mouseDown = true;
          startMouseX = event.clientX;
          startMouseY = event.clientY;
          startTheta = theta;
          startPhi = phi;
        },
        false
      );
      document.addEventListener(
        "mouseup",
        function(event) {
          event.preventDefault();
          mouseDown = false;
          startMouseX = event.clientX - startMouseX;
          startMouseY = event.clientY - startMouseY;
        },
        false
      );

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        //camera.position.set(40, 30, 0);
        camera.position.set(40, 10, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        radius = Math.sqrt(
          Math.pow(camera.position.x, 2) +
          Math.pow(camera.position.y, 2) +
          Math.pow(camera.position.z, 2)
        );

        // Draw a helper grid in the x-z plane.
        scene.add(new THREE.GridHelper(30, 100, 0xffffff));

        var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );
        for (i = -15; i <= 15; i++) {
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3( 0, 20, i) );
          geometry.vertices.push(new THREE.Vector3( 0, 0, i) );
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line)
        }
        for (i = 0; i <= 20; i++) {
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3( 0, i, -15) );
          geometry.vertices.push(new THREE.Vector3( 0, i, 15) );
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line)
        }

        // Add directional lighting to scene.
        var directionalLight = new THREE.DirectionalLight(0xffffffff, 1.2);
        directionalLight.position.x = 10;
        directionalLight.position.y = 10;
        directionalLight.position.z = 0;
        directionalLight.intensity = 1.5;
        scene.add(directionalLight);
        var ambientLight = new THREE.AmbientLight();
        ambientLight.intensity = 0.2;
        scene.add(ambientLight);

        // Set up the Web GL renderer.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        // Handle resizing of the browser window.
        window.addEventListener("resize", handleResize, false);

        createNew();
      }

      function animate() {
        requestAnimationFrame(animate);

        next = moveDown();
        if (next) {
          createL();
        }

        // Render the current scene to the screen.
        renderer.clear();
        renderer.render(scene, camera);
      }

      function moveDown() {
        // Check at bottom
        currentBlock = blocks.pop();
        halt = false;
        for (i = 0; i < currentBlock.children.length; i++) {
          if (currentBlock.children[i].position.y <= cubeLen/2) {
            halt = true
          }
        }
        // With every other block in the blocks list
        for (x = 0; x < blocks.length; x++) {
          checkBlock = blocks[x];
          // Check checkBlocks children against currentBlocks children
          for (i = 0; i < currentBlock.children.length; i++) {
            var potentialPosition = new THREE.Vector3();
            potentialPosition = currentBlock.children[i].position;
            potentialPosition.y = potentialPosition.y - 1;
            for (j = 0; j < checkBlock.children.length; j++) {
              // If positions would be equal, currentBlock cannot move down
              console.debug(potentialPosition.x, potentialPosition.y, potentialPosition.z, checkBlock.children[j].position.x, checkBlock.children[j].position.y, checkBlock.children[j].position.z);
              
              if (potentialPosition.x == checkBlock.children[j].position.x && potentialPosition.y == checkBlock.children[j].position.y && potentialPosition.z == checkBlock.children[j].position.z) {
                halt = true;
                break
              }
            }
            if (halt) {
              break
            }
          }
          if (halt) {
            break
          }
        }
        console.debug();

        // Move currentBlock one space down
        if (!halt) {
          for (i = 0; i < currentBlock.children.length; i++) {
            currentBlock.children[i].position.y = currentBlock.children[i].position.y - 1;
          }
        }
        blocks.push(currentBlock);
        return halt;
      }

      function createNew() {
        createL();
        moveDown();
      }

      /* Handle resizing of the browser window. */
      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      /* A basic cube used to create any block */
      function createCube(colour) {
        var geometry = new THREE.BoxGeometry(cubeLen, cubeLen, cubeLen);
        var material = new THREE.MeshPhongMaterial({ color: colour });
        var cube = new THREE.Mesh(geometry, material);

        return cube;
      }

      function getRandomColour() {
        var letters = '0123456789ABCDEF';
        var colour = '#';
        for (var i = 0; i < 6; i++) {
          colour += letters[Math.floor(Math.random() * 16)];
        }
        return colour;
      }

      /*  1
          2
          3
          4 5
      */
      function createL() {
        var block = new THREE.Group();
        var cubes = [];
        var colour = getRandomColour();
        for (i = 0; i < 5; i++) {
          cubes.push(createCube(colour));
        }
        cubes[0].position.set(0, gameHeight + cubeLen/2, 0);
        cubes[1].position.set(0, gameHeight + cubeLen/2 - 1, 0);
        cubes[2].position.set(0, gameHeight + cubeLen/2 - 2, 0);
        cubes[3].position.set(0, gameHeight + cubeLen/2 - 3, 0);
        cubes[4].position.set(0, gameHeight + cubeLen/2 - 3, -1);
        for (i = 0; i < cubes.length; i++) {
          block.add(cubes[i]);
        }
        blocks.push(block);
        end++;
        scene.add(block);
      }

      // Handle keyboard presses.
      function handleKeyDown(event) {
        switch (event.keyCode) {
          case 37: // Left arrow
            break
          case 38: // Up arrow
            break
          case 39: // Right arrow
            break
          case 40: // Down arrow
            break
        }
      }

      // Control camera orbit
      function handleMouseMove(event) {
        if (mouseDown) {
          theta = -((event.clientX - startMouseX) * 0.5) + startTheta;
          phi = Math.min(
            180,
            Math.max(0, (event.clientY - startMouseY) * 0.5 + startPhi)
          );

          camera.position.x =
            radius *
            Math.sin((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.position.y = radius * Math.sin((phi * Math.PI) / 360);
          camera.position.z =
            radius *
            Math.cos((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.lookAt(new THREE.Vector3(0, 0, 0));
          camera.updateMatrix();
        }
      }
    </script>
  </body>
</html>