<html>
  <head>
    <title>3D TetrisL</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script src="three.js"></script>
    <script>
      var scene, camera, radius;
      var blocks = [];
      var cubeLen = 1;
      var end = -1;
      var gameWidth = 10;
      var gameHeight = 16;
      var mouseDown = false;
      var startMouseX, startMouseY, mouseX, mouseY;
      startMouseX = mouseX = startMouseY = mouseY = 0;
      var startTheta, theta, startPhi, phi;
      startTheta = theta = 180;
      startPhi = phi = 74;
      var radius;

      
      init();
      animate();

      // Listen for keyboard events, to react to them.
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("mousemove", handleMouseMove);
      document.body.addEventListener(
        "mousedown",
        function(event) {
          event.preventDefault();
          mouseDown = true;
          startMouseX = event.clientX;
          startMouseY = event.clientY;
          startTheta = theta;
          startPhi = phi;
        },
        false
      );
      document.addEventListener(
        "mouseup",
        function(event) {
          event.preventDefault();
          mouseDown = false;
          startMouseX = event.clientX - startMouseX;
          startMouseY = event.clientY - startMouseY;
        },
        false
      );

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(50, 40, 0);
        //camera.position.set(40, 10, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        radius = Math.sqrt(
          Math.pow(camera.position.x, 2) +
          Math.pow(camera.position.y, 2) +
          Math.pow(camera.position.z, 2)
        );

        // Draw a helper grid in the x-z plane.
        scene.add(new THREE.GridHelper(30, 60, 0xffffff));

        // Create vertical grid
        var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );
        for (x = -0.5; x <= 0.5; x++) {
          // Create vertical lines
          for (i = -14.5; i <= 14.5; i++) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3( x, gameHeight * 1.5, i) );
            geometry.vertices.push(new THREE.Vector3( x, 0, i) );
            var line = new THREE.Line(geometry, lineMaterial);
            scene.add(line)
          }
          // Create horizonal lines
          for (i = 0; i <= gameHeight * 1.5; i++) {
            var geometry = new THREE.Geometry();
            if (i == gameHeight) {
              lineMaterial = new THREE.LineBasicMaterial( { color: 0xff0000 } );
            }
            geometry.vertices.push(new THREE.Vector3( x, i, -14.5) );
            geometry.vertices.push(new THREE.Vector3( x, i, 14.5) );
            var line = new THREE.Line(geometry, lineMaterial);
            scene.add(line)
            if (i == gameHeight) {
              lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );
            }
          }
        }

        // Add directional lighting to scene.
        var directionalLight = new THREE.DirectionalLight(0xffffffff, 1.2);
        directionalLight.position.x = 10;
        directionalLight.position.y = 10;
        directionalLight.position.z = 0;
        directionalLight.intensity = 1.5;
        scene.add(directionalLight);
        var ambientLight = new THREE.AmbientLight();
        ambientLight.intensity = 0.2;
        scene.add(ambientLight);

        // Set up the Web GL renderer.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        // Handle resizing of the browser window.
        window.addEventListener("resize", handleResize, false);

        initialiseGame();
      }

      function animate() {
        requestAnimationFrame(animate);

        next = moveDown();
        if (next) {
          if (!gameOver()) {
            random = Math.ceil(Math.random() * 5)
            switch (random) {
              case 1:
                createL();
              case 2:
                createLine();
              case 3:
                createSquare();
          }
        }
        // Render the current scene to the screen.
        renderer.clear();
        renderer.render(scene, camera);
      }

      function gameOver() {
        over = false;
        
        for (i = 0; i < blocks.length; i++) {
          childLen = blocks[i].children.length; 
          for (j = 0; j < childLen; j++) {
            if (blocks[i].children[j].position.y >= gameHeight - cubeLen/2) {
              over = true;
            }
          }
        }

        return over;
      }

      function initialiseGame() {
        createL();
        moveDown();
      }

      /* Handle resizing of the browser window. */
      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }




      /* A basic cube used to create any block */
      function createCube(colour) {
        var geometry = new THREE.BoxGeometry(cubeLen, cubeLen, cubeLen);
        var material = new THREE.MeshPhongMaterial({ color: colour });
        var cube = new THREE.Mesh(geometry, material);

        return cube;
      }

      /* Creates and returns a random colour hex code */ 
      function getRandomColour() {
        var letters = '0123456789ABCDEF';
        var colour = '#';
        for (var i = 0; i < 6; i++) {
          colour += letters[Math.floor(Math.random() * 16)];
        }
        return colour;
      }

      /*  1
          2
          3
          4 5
      */
      function createL() {
        var block = new THREE.Group();
        var cubes = [];
        var colour = getRandomColour();
        for (i = 0; i < 5; i++) {
          cubes.push(createCube(colour));
        }
        cubes[0].position.set(0, gameHeight - cubeLen/2 + cubes.length, 0);
        cubes[1].position.set(0, gameHeight - cubeLen/2 + cubes.length - 1, 0);
        cubes[2].position.set(0, gameHeight - cubeLen/2 + cubes.length - 2, 0);
        cubes[3].position.set(0, gameHeight - cubeLen/2 + cubes.length - 3, 0);
        cubes[4].position.set(0, gameHeight - cubeLen/2 + cubes.length - 3, -1);
        for (i = 0; i < cubes.length; i++) {
          block.add(cubes[i]);
        }
        blocks.push(block);
        end++;
        scene.add(block);
      }

      /*  1
          2
          3
          4
      */
      function createLine() {
        var block = new THREE.Group();
        var cubes = [];
        var colour = getRandomColour();
        for (i = 0; i < 4; i++) {
          cubes.push(createCube(colour));
        }
        cubes[0].position.set(0, gameHeight - cubeLen/2 + cubes.length, 0);
        cubes[1].position.set(0, gameHeight - cubeLen/2 + cubes.length - 1, 0);
        cubes[2].position.set(0, gameHeight - cubeLen/2 + cubes.length - 2, 0);
        cubes[3].position.set(0, gameHeight - cubeLen/2 + cubes.length - 3, 0);
        for (i = 0; i < cubes.length; i++) {
          block.add(cubes[i]);
        }
        blocks.push(block);
        end++;
        scene.add(block);
      }

      /*  1 2
          3 4
      */
      function createSquare() {
        var block = new THREE.Group();
        var cubes = [];
        var colour = getRandomColour();
        for (i = 0; i < 4; i++) {
          cubes.push(createCube(colour));
        }
        cubes[0].position.set(0, gameHeight - cubeLen/2 + cubes.length/2, 0);
        cubes[1].position.set(0, gameHeight - cubeLen/2 + cubes.length/2, -1);
        cubes[2].position.set(0, gameHeight - cubeLen/2 + cubes.length/2 - 1, 0);
        cubes[3].position.set(0, gameHeight - cubeLen/2 + cubes.length/2 - 1, -1);
        for (i = 0; i < cubes.length; i++) {
          block.add(cubes[i]);
        }
        blocks.push(block);
        end++;
        scene.add(block);
      }




      /* Move the current block either left or right depending on input */
      function moveLeftRight(direction) {
        add = 0
        if (direction == 'left') {
          add = 1
        } else if (direction == 'right') {
          add = -1
        }

        // Check at left edge of game space
        currentBlock = blocks.pop();
        halt = false;
        for (i = 0; i < currentBlock.children.length; i++) {
          if (Math.abs(currentBlock.children[i].position.z) >= gameWidth) {
            halt = true
          }
        }
        if (!halt) {
          // With every other block in the blocks list
          for (x = 0; x < blocks.length; x++) {
            checkBlock = blocks[x];
            // Check checkBlocks children position against potential position
            // of currentBlocks children 
            for (i = 0; i < currentBlock.children.length; i++) {
              var potentialPosition = new THREE.Vector3();
              potentialPosition = JSON.parse(JSON.stringify(currentBlock.children[i].position));
              potentialPosition.z = potentialPosition.z + add;
              for (j = 0; j < checkBlock.children.length; j++) {
                // If positions would be equal, currentBlock cannot move down                
                if (potentialPosition.x == checkBlock.children[j].position.x && potentialPosition.y == checkBlock.children[j].position.y && potentialPosition.z == checkBlock.children[j].position.z) {
                  halt = true;
                  break
                }
              }
              if (halt) {
                break
              }
            }
            if (halt) {
              break
            }
          }
        }

        // Move currentBlock one space down
        if (!halt) {
          for (i = 0; i < currentBlock.children.length; i++) {
            currentBlock.children[i].position.z = currentBlock.children[i].position.z + add;
          }
        }
        blocks.push(currentBlock);
        return halt;
      }

      /* Move the current block down a block */
      function moveDown() {
        // Check at bottom
        currentBlock = blocks.pop();
        halt = false;
        for (i = 0; i < currentBlock.children.length; i++) {
          if (currentBlock.children[i].position.y <= cubeLen/2) {
            halt = true
          }
        }
        if (!halt) {
          // With every other block in the blocks list
          for (x = 0; x < blocks.length; x++) {
            checkBlock = blocks[x];
            // Check checkBlocks children against currentBlocks children
            for (i = 0; i < currentBlock.children.length; i++) {
              var potentialPosition = new THREE.Vector3();
              potentialPosition = JSON.parse(JSON.stringify(currentBlock.children[i].position));
              potentialPosition.y = potentialPosition.y - 1;
              for (j = 0; j < checkBlock.children.length; j++) {
                // If positions would be equal, currentBlock cannot move down                
                if (potentialPosition.x == checkBlock.children[j].position.x && potentialPosition.y == checkBlock.children[j].position.y && potentialPosition.z == checkBlock.children[j].position.z) {
                  halt = true;
                  break
                }
              }
              if (halt) {
                break
              }
            }
            if (halt) {
              break
            }
          }
        }

        // Move currentBlock one space down
        if (!halt) {
          for (i = 0; i < currentBlock.children.length; i++) {
            currentBlock.children[i].position.y = currentBlock.children[i].position.y - 1;
          }
        }
        blocks.push(currentBlock);
        return halt;
      }

      // Handle keyboard presses.
      function handleKeyDown(event) {
        switch (event.keyCode) {
          case 37: // Left arrow
            moveLeftRight('left');
            break
          case 39: // Right arrow
            moveLeftRight('right');
            break
          case 40: // Down arrow
            moveDown();
            break
        }
      }

      // Control camera orbit
      function handleMouseMove(event) {
        if (mouseDown) {
          theta = -((event.clientX - startMouseX) * 0.5) + startTheta;
          phi = Math.min(
            180,
            Math.max(0, (event.clientY - startMouseY) * 0.5 + startPhi)
          );

          camera.position.x =
            radius *
            Math.sin((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.position.y = radius * Math.sin((phi * Math.PI) / 360);
          camera.position.z =
            radius *
            Math.cos((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.lookAt(new THREE.Vector3(0, 0, 0));
          camera.updateMatrix();
        }
      }
    </script>
  </body>
</html>