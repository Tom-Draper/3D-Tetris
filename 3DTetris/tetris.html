<html>
  <head>
    <title>3D TetrisL</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script src="three.js"></script>
    <script>
      var scene, camera, radius;
      var currentBlock;
      var gameWidth = 10;
      var gameHeight = 5;
      var mouseDown = false;
      var startMouseX, startMouseY, mouseX, mouseY;
      startMouseX = mouseX = startMouseY = mouseY = 0;
      var startTheta, theta, startPhi, phi;
      startTheta = theta = 180;
      startPhi = phi = 74;
      var radius;

      
      init();
      animate();
      startGame();

      // Listen for keyboard events, to react to them.
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("mousemove", handleMouseMove);
      document.body.addEventListener(
        "mousedown",
        function(event) {
          event.preventDefault();
          mouseDown = true;
          startMouseX = event.clientX;
          startMouseY = event.clientY;
          startTheta = theta;
          startPhi = phi;
        },
        false
      );
      document.addEventListener(
        "mouseup",
        function(event) {
          event.preventDefault();
          mouseDown = false;
          startMouseX = event.clientX - startMouseX;
          startMouseY = event.clientY - startMouseY;
        },
        false
      );

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(40, 30, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        radius = Math.sqrt(
          Math.pow(camera.position.x, 2) +
          Math.pow(camera.position.y, 2) +
          Math.pow(camera.position.z, 2)
        );

        // Draw a helper grid in the x-z plane.
        scene.add(new THREE.GridHelper(30, 30, 0xffffff));

        // Add directional lighting to scene.
        var directionalLight = new THREE.DirectionalLight(0xffffffff, 1.2);
        directionalLight.position.x = 10;
        directionalLight.position.y = 10;
        directionalLight.position.z = 0;
        directionalLight.intensity = 1.5;
        scene.add(directionalLight);

        // Set up the Web GL renderer.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        // Handle resizing of the browser window.
        window.addEventListener("resize", handleResize, false);
      }

      function animate() {
        requestAnimationFrame(animate);

        moveDown();

        // Render the current scene to the screen.
        renderer.clear();
        renderer.render(scene, camera);
      }

      function moveDown() {
        setTimeout(() => {
          if (currentBlock.position.y > 0) {
            currentBlock.position.y = currentBlock.position.y - 1;
          }
        }, 1000);
      }

      function startGame() {
        createL();
      }

      // Handle resizing of the browser window.
      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function createCube() {
        var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        var cube = new THREE.Mesh(geometry, material);

        return cube;
      }

      /*  1
          2
          3
          4 5
      */
      function createL() {
        var block = new THREE.Group();
        var cube1 = createCube();
        var cube2 = createCube();
        var cube3 = createCube();
        var cube4 = createCube();
        var cube5 = createCube();
        cube1.position.set(0, gameHeight, 0);
        cube2.position.set(0, gameHeight - 1, 0);
        cube3.position.set(0, gameHeight - 2, 0);
        cube4.position.set(0, gameHeight - 3, 0);
        cube5.position.set(0, gameHeight - 3, -1);
        block.add(cube1);
        block.add(cube2);
        block.add(cube3);
        block.add(cube4);
        block.add(cube5);
        currentBlock = block;
        scene.add(block);
      }

      // Handle keyboard presses.
      function handleKeyDown(event) {
        switch (event.keyCode) {
          case 37: // Left arrow
            break
          case 38: // Up arrow
            break
          case 39: // Right arrow
            break
          case 40: // Down arrow
            break
        }
      }

      // Control camera orbit
      function handleMouseMove(event) {
        if (mouseDown) {
          theta = -((event.clientX - startMouseX) * 0.5) + startTheta;
          phi = Math.min(
            180,
            Math.max(0, (event.clientY - startMouseY) * 0.5 + startPhi)
          );

          camera.position.x =
            radius *
            Math.sin((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.position.y = radius * Math.sin((phi * Math.PI) / 360);
          camera.position.z =
            radius *
            Math.cos((theta * Math.PI) / 360) *
            Math.cos((phi * Math.PI) / 360);
          camera.lookAt(new THREE.Vector3(0, 0, 0));
          camera.updateMatrix();
        }
      }
    </script>
  </body>
</html>